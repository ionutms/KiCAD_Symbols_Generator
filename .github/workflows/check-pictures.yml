name: Check Pictures from Source Repo

on:
  repository_dispatch:
    types: [check_pictures]

jobs:
  check-and-save:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout target repo (KiCAD_Symbols_Generator)
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.TRAFIC_UPDATE_TOKEN }}
      
      - name: Checkout source repo
        uses: actions/checkout@v4
        with:
          repository: ${{ github.event.client_payload.source_repo }}
          ref: ${{ github.event.client_payload.source_ref }}
          token: ${{ secrets.TRAFIC_UPDATE_TOKEN }}
          path: source-repo
      
      - name: List pictures and update file
        run: |
          PICTURES_PATH="source-repo/${{ github.event.client_payload.pictures_path }}"
          OUTPUT_FILE="app/pictures.txt"
          METADATA_FILE="app/.picture_metadata.txt"
          SOURCE_REPO="${{ github.event.client_payload.source_repo }}"
          TEMP_FILE="temp_pictures.txt"
          MANUAL_ENTRIES="manual_entries.tmp"
          
          # Create app directory if it doesn't exist
          mkdir -p app
          
          # Get list of new pictures with repo prefix, removing BOM and special characters
          if [ -d "$PICTURES_PATH" ]; then
            NEW_PICTURES=$(ls -1 "$PICTURES_PATH" | sed 's/^\xEF\xBB\xBF//g' | sed "s|^|$SOURCE_REPO:|")
            echo "Found $(ls -1 "$PICTURES_PATH" | wc -l) files from $SOURCE_REPO"
          else
            NEW_PICTURES=""
            echo "Directory not found for $SOURCE_REPO"
          fi
          
          # Create or read metadata file
          touch "$METADATA_FILE"
          touch "$OUTPUT_FILE"
          
          # Find manual entries (in output but not in metadata), excluding empty lines
          if [ -f "$OUTPUT_FILE" ] && [ -f "$METADATA_FILE" ]; then
            # Get filenames from metadata
            awk -F: '{print $2}' "$METADATA_FILE" | sort | uniq > metadata_files.tmp
            # Get current output files, remove empty lines and BOM
            grep -v '^[[:space:]]*$' "$OUTPUT_FILE" | sed 's/^\xEF\xBB\xBF//g' | sort | uniq > output_files.tmp
            # Find entries only in output (manual additions)
            comm -13 metadata_files.tmp output_files.tmp > "$MANUAL_ENTRIES"
            rm -f metadata_files.tmp output_files.tmp
          else
            touch "$MANUAL_ENTRIES"
          fi
          
          # Remove old entries from this repo and keep others
          grep -v "^$SOURCE_REPO:" "$METADATA_FILE" > "$TEMP_FILE" || true
          
          # Add new entries
          echo "$NEW_PICTURES" >> "$TEMP_FILE"
          
          # Sort by repo name, then by filename, and save metadata
          sort "$TEMP_FILE" > "$METADATA_FILE"
          
          # Generate output file with filenames grouped by repo with blank lines
          > "$OUTPUT_FILE"
          CURRENT_REPO=""
          while IFS=: read -r repo filename; do
            if [ "$CURRENT_REPO" != "$repo" ]; then
              if [ -n "$CURRENT_REPO" ]; then
                echo "" >> "$OUTPUT_FILE"
              fi
              CURRENT_REPO="$repo"
            fi
            echo "$filename" >> "$OUTPUT_FILE"
          done < "$METADATA_FILE"
          
          # Append manual entries at the end if any exist
          if [ -s "$MANUAL_ENTRIES" ]; then
            echo "Preserving $(wc -l < "$MANUAL_ENTRIES") manual entries"
            if [ -s "$OUTPUT_FILE" ]; then
              echo "" >> "$OUTPUT_FILE"
            fi
            cat "$MANUAL_ENTRIES" >> "$OUTPUT_FILE"
          fi
          
          rm -f "$TEMP_FILE" "$MANUAL_ENTRIES"
      
      - name: Commit and push changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add app/pictures.txt app/.picture_metadata.txt
          git diff --quiet && git diff --staged --quiet || (git commit -m "Update picture names from ${{ github.event.client_payload.source_repo }}" && git push)